"""
Sentinel Agent - Proactive Monitoring System.

Runs as a background daemon to:
- Periodically scan critical hosts
- Detect anomalies before they become incidents
- Automatically create incidents in the knowledge graph
- Optionally trigger auto-remediation

This shifts Athena from reactive to proactive mode.
"""

import threading
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

from athena_ai.knowledge import get_knowledge_manager
from athena_ai.utils.logger import logger


class SentinelStatus(Enum):
    """Sentinel operational status."""
    STOPPED = "stopped"
    RUNNING = "running"
    PAUSED = "paused"
    ERROR = "error"


class AlertSeverity(Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class HealthCheck:
    """Definition of a health check."""
    name: str
    target: str  # Host or service to check
    check_type: str  # "ping", "port", "http", "custom"
    interval_seconds: int = 60
    timeout_seconds: int = 10
    threshold_failures: int = 3  # Consecutive failures to trigger alert
    parameters: Dict[str, Any] = field(default_factory=dict)
    enabled: bool = True


@dataclass
class CheckResult:
    """Result of a health check."""
    check: HealthCheck
    success: bool
    response_time_ms: float
    timestamp: str
    error: Optional[str] = None
    details: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Alert:
    """An alert generated by the sentinel."""
    id: str
    check_name: str
    target: str
    severity: AlertSeverity
    message: str
    timestamp: str
    consecutive_failures: int
    incident_id: Optional[str] = None  # If incident was created
    acknowledged: bool = False


class SentinelAgent:
    """
    Proactive monitoring agent that runs in background.

    Features:
    - Configurable health checks (ping, port, HTTP, custom)
    - Anomaly detection based on thresholds
    - Automatic incident creation
    - Integration with RemediationAgent for auto-healing
    - Alert callbacks for notifications

    Usage:
        sentinel = SentinelAgent()

        # Add checks
        sentinel.add_check(HealthCheck(
            name="web-prod-health",
            target="web-prod-1",
            check_type="http",
            parameters={"url": "http://web-prod-1/health", "expected_status": 200}
        ))

        # Start monitoring
        sentinel.start()

        # Later...
        sentinel.stop()
    """

    def __init__(
        self,
        executor=None,
        auto_remediate: bool = False,
        remediation_mode: str = "conservative",
        alert_callback: Optional[Callable[[Alert], None]] = None,
    ):
        """
        Initialize SentinelAgent.

        Args:
            executor: Command executor for running checks
            auto_remediate: Enable automatic remediation
            remediation_mode: Mode for RemediationAgent if auto_remediate=True
            alert_callback: Callback for alert notifications
        """
        self.executor = executor
        self.auto_remediate = auto_remediate
        self.remediation_mode = remediation_mode
        self.alert_callback = alert_callback or self._default_alert_handler

        self.knowledge = get_knowledge_manager()
        self.status = SentinelStatus.STOPPED

        # Health checks configuration
        self._checks: Dict[str, HealthCheck] = {}
        self._check_results: Dict[str, List[CheckResult]] = {}
        self._failure_counts: Dict[str, int] = {}
        self._alerts: Dict[str, Alert] = {}

        # Background thread
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
        self._lock = threading.Lock()

        # Stats
        self._stats = {
            "checks_run": 0,
            "checks_passed": 0,
            "checks_failed": 0,
            "alerts_created": 0,
            "incidents_created": 0,
            "remediations_triggered": 0,
            "started_at": None,
        }

    def _default_alert_handler(self, alert: Alert):
        """Default alert handler - logs the alert."""
        logger.warning(
            f"SENTINEL ALERT [{alert.severity.value.upper()}]: "
            f"{alert.target} - {alert.message}"
        )

    # =========================================================================
    # Check Management
    # =========================================================================

    def add_check(self, check: HealthCheck) -> bool:
        """Add a health check."""
        with self._lock:
            if check.name in self._checks:
                logger.warning(f"Check '{check.name}' already exists, updating")

            self._checks[check.name] = check
            self._check_results[check.name] = []
            self._failure_counts[check.name] = 0

            logger.info(f"Added check: {check.name} ({check.check_type}) -> {check.target}")
            return True

    def remove_check(self, name: str) -> bool:
        """Remove a health check."""
        with self._lock:
            if name not in self._checks:
                return False

            del self._checks[name]
            self._check_results.pop(name, None)
            self._failure_counts.pop(name, None)

            logger.info(f"Removed check: {name}")
            return True

    def enable_check(self, name: str) -> bool:
        """Enable a health check."""
        with self._lock:
            if name in self._checks:
                self._checks[name].enabled = True
                return True
            return False

    def disable_check(self, name: str) -> bool:
        """Disable a health check."""
        with self._lock:
            if name in self._checks:
                self._checks[name].enabled = False
                return True
            return False

    def list_checks(self) -> List[HealthCheck]:
        """List all health checks."""
        with self._lock:
            return list(self._checks.values())

    # =========================================================================
    # Lifecycle Management
    # =========================================================================

    def start(self) -> bool:
        """Start the sentinel monitoring."""
        if self.status == SentinelStatus.RUNNING:
            logger.warning("Sentinel is already running")
            return False

        if not self._checks:
            logger.warning("No health checks configured")
            return False

        self._stop_event.clear()
        self._thread = threading.Thread(
            target=self._monitoring_loop,
            name="SentinelAgent",
            daemon=True,
        )
        self._thread.start()

        self.status = SentinelStatus.RUNNING
        self._stats["started_at"] = datetime.now().isoformat()

        logger.info(f"Sentinel started with {len(self._checks)} checks")
        return True

    def stop(self) -> bool:
        """Stop the sentinel monitoring."""
        if self.status != SentinelStatus.RUNNING:
            return False

        self._stop_event.set()

        if self._thread:
            self._thread.join(timeout=5)
            self._thread = None

        self.status = SentinelStatus.STOPPED
        logger.info("Sentinel stopped")
        return True

    def pause(self) -> bool:
        """Pause monitoring without stopping the thread."""
        if self.status == SentinelStatus.RUNNING:
            self.status = SentinelStatus.PAUSED
            logger.info("Sentinel paused")
            return True
        return False

    def resume(self) -> bool:
        """Resume monitoring after pause."""
        if self.status == SentinelStatus.PAUSED:
            self.status = SentinelStatus.RUNNING
            logger.info("Sentinel resumed")
            return True
        return False

    # =========================================================================
    # Monitoring Loop
    # =========================================================================

    def _monitoring_loop(self):
        """Main monitoring loop running in background thread."""
        check_schedules: Dict[str, float] = {}

        while not self._stop_event.is_set():
            if self.status == SentinelStatus.PAUSED:
                time.sleep(1)
                continue

            current_time = time.time()

            with self._lock:
                checks_to_run = []
                for name, check in self._checks.items():
                    if not check.enabled:
                        continue

                    last_run = check_schedules.get(name, 0)
                    if current_time - last_run >= check.interval_seconds:
                        checks_to_run.append(check)
                        check_schedules[name] = current_time

            # Run checks outside lock
            for check in checks_to_run:
                try:
                    result = self._run_check(check)
                    self._process_result(result)
                except Exception as e:
                    logger.error(f"Error running check {check.name}: {e}")
                    self.status = SentinelStatus.ERROR

            # Sleep briefly to avoid busy loop
            time.sleep(1)

    def _run_check(self, check: HealthCheck) -> CheckResult:
        """Run a single health check."""
        start_time = time.time()
        success = False
        error = None
        details = {}

        try:
            if check.check_type == "ping":
                success, details = self._check_ping(check)
            elif check.check_type == "port":
                success, details = self._check_port(check)
            elif check.check_type == "http":
                success, details = self._check_http(check)
            elif check.check_type == "command":
                success, details = self._check_command(check)
            elif check.check_type == "disk":
                success, details = self._check_disk(check)
            elif check.check_type == "memory":
                success, details = self._check_memory(check)
            elif check.check_type == "process":
                success, details = self._check_process(check)
            else:
                error = f"Unknown check type: {check.check_type}"
        except Exception as e:
            error = str(e)

        response_time = (time.time() - start_time) * 1000  # ms

        self._stats["checks_run"] += 1
        if success:
            self._stats["checks_passed"] += 1
        else:
            self._stats["checks_failed"] += 1

        return CheckResult(
            check=check,
            success=success,
            response_time_ms=response_time,
            timestamp=datetime.now().isoformat(),
            error=error,
            details=details,
        )

    def _check_ping(self, check: HealthCheck) -> tuple:
        """Check host reachability via ping."""
        import subprocess

        target = check.target
        count = check.parameters.get("count", 1)

        try:
            result = subprocess.run(
                ["ping", "-c", str(count), "-W", str(check.timeout_seconds), target],
                capture_output=True,
                timeout=check.timeout_seconds + 2,
            )
            return result.returncode == 0, {"exit_code": result.returncode}
        except subprocess.TimeoutExpired:
            return False, {"error": "timeout"}
        except Exception as e:
            return False, {"error": str(e)}

    def _check_port(self, check: HealthCheck) -> tuple:
        """Check if a port is open."""
        import socket

        target = check.target
        port = check.parameters.get("port", 22)

        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(check.timeout_seconds)
            result = sock.connect_ex((target, port))
            sock.close()
            return result == 0, {"port": port, "result": result}
        except Exception as e:
            return False, {"error": str(e)}

    def _check_http(self, check: HealthCheck) -> tuple:
        """Check HTTP endpoint."""
        import urllib.error
        import urllib.request

        url = check.parameters.get("url", f"http://{check.target}/")
        expected_status = check.parameters.get("expected_status", 200)

        try:
            req = urllib.request.Request(url, method="GET")
            with urllib.request.urlopen(req, timeout=check.timeout_seconds) as response:
                status = response.status
                return status == expected_status, {"status": status, "expected": expected_status}
        except urllib.error.HTTPError as e:
            return e.code == expected_status, {"status": e.code, "expected": expected_status}
        except Exception as e:
            return False, {"error": str(e)}

    def _check_command(self, check: HealthCheck) -> tuple:
        """Run a custom command and check exit code."""
        if not self.executor:
            return False, {"error": "No executor configured"}

        command = check.parameters.get("command", "true")
        expected_exit = check.parameters.get("expected_exit", 0)

        result = self.executor.execute(check.target, command, confirm=False)
        success = result.get("exit_code", 1) == expected_exit

        return success, {"exit_code": result.get("exit_code"), "expected": expected_exit}

    def _check_disk(self, check: HealthCheck) -> tuple:
        """Check disk usage threshold."""
        if not self.executor:
            return False, {"error": "No executor configured"}

        threshold = check.parameters.get("threshold_percent", 90)
        path = check.parameters.get("path", "/")

        result = self.executor.execute(
            check.target,
            f"df -h {path} | tail -1 | awk '{{print $5}}' | tr -d '%'",
            confirm=False,
        )

        if result.get("success"):
            try:
                usage = int(result.get("stdout", "100").strip())
                return usage < threshold, {"usage_percent": usage, "threshold": threshold}
            except ValueError:
                return False, {"error": "Could not parse disk usage"}

        return False, {"error": result.get("stderr", "Unknown error")}

    def _check_memory(self, check: HealthCheck) -> tuple:
        """Check memory usage threshold."""
        if not self.executor:
            return False, {"error": "No executor configured"}

        threshold = check.parameters.get("threshold_percent", 90)

        result = self.executor.execute(
            check.target,
            "free | grep Mem | awk '{print int($3/$2 * 100)}'",
            confirm=False,
        )

        if result.get("success"):
            try:
                usage = int(result.get("stdout", "100").strip())
                return usage < threshold, {"usage_percent": usage, "threshold": threshold}
            except ValueError:
                return False, {"error": "Could not parse memory usage"}

        return False, {"error": result.get("stderr", "Unknown error")}

    def _check_process(self, check: HealthCheck) -> tuple:
        """Check if a process is running."""
        if not self.executor:
            return False, {"error": "No executor configured"}

        process_name = check.parameters.get("process", "")
        if not process_name:
            return False, {"error": "No process name specified"}

        result = self.executor.execute(
            check.target,
            f"pgrep -x {process_name}",
            confirm=False,
        )

        return result.get("success", False), {"process": process_name}

    # =========================================================================
    # Result Processing
    # =========================================================================

    def _process_result(self, result: CheckResult):
        """Process a check result and handle alerts."""
        check_name = result.check.name

        with self._lock:
            # Store result history (keep last 100)
            self._check_results[check_name].append(result)
            if len(self._check_results[check_name]) > 100:
                self._check_results[check_name] = self._check_results[check_name][-100:]

            if result.success:
                # Reset failure count on success
                if self._failure_counts[check_name] > 0:
                    logger.info(f"Check {check_name} recovered after {self._failure_counts[check_name]} failures")
                self._failure_counts[check_name] = 0

                # Clear active alert if any
                if check_name in self._alerts:
                    del self._alerts[check_name]
            else:
                # Increment failure count
                self._failure_counts[check_name] += 1
                failures = self._failure_counts[check_name]

                # Check if threshold reached
                if failures >= result.check.threshold_failures:
                    self._create_alert(result)

    def _create_alert(self, result: CheckResult):
        """Create an alert for a failed check."""
        check = result.check
        failures = self._failure_counts[check.name]

        # Determine severity
        if failures >= check.threshold_failures * 3:
            severity = AlertSeverity.CRITICAL
        elif failures >= check.threshold_failures * 2:
            severity = AlertSeverity.WARNING
        else:
            severity = AlertSeverity.INFO

        # Create alert
        alert_id = f"alert_{check.name}_{int(time.time())}"
        alert = Alert(
            id=alert_id,
            check_name=check.name,
            target=check.target,
            severity=severity,
            message=result.error or f"Check failed {failures} times",
            timestamp=result.timestamp,
            consecutive_failures=failures,
        )

        # Store alert
        self._alerts[check.name] = alert
        self._stats["alerts_created"] += 1

        # Notify via callback
        self.alert_callback(alert)

        # Create incident if critical
        if severity == AlertSeverity.CRITICAL:
            self._create_incident(alert, result)

        # Trigger remediation if enabled
        if self.auto_remediate and severity in [AlertSeverity.WARNING, AlertSeverity.CRITICAL]:
            self._trigger_remediation(alert, result)

    def _create_incident(self, alert: Alert, result: CheckResult):
        """Create an incident in the knowledge graph."""
        try:
            symptoms = [
                f"{result.check.check_type} check failed",
                result.error or "Unknown error",
            ]

            if result.details:
                for key, value in result.details.items():
                    symptoms.append(f"{key}: {value}")

            # Map severity to priority
            priority_map = {
                AlertSeverity.CRITICAL: "P1",
                AlertSeverity.WARNING: "P2",
                AlertSeverity.INFO: "P3",
            }

            incident_id = self.knowledge.record_incident(
                title=f"[Sentinel] {alert.check_name}: {alert.message}",
                priority=priority_map.get(alert.severity, "P2"),
                description=f"Automatically detected by Sentinel Agent after {alert.consecutive_failures} consecutive failures",
                service=result.check.parameters.get("service", result.check.target),
                host=result.check.target,
                symptoms=symptoms,
                tags=["sentinel", "auto-detected", result.check.check_type],
            )

            alert.incident_id = incident_id
            self._stats["incidents_created"] += 1

            logger.info(f"Created incident {incident_id} for alert {alert.id}")

        except Exception as e:
            logger.error(f"Failed to create incident: {e}")

    def _trigger_remediation(self, alert: Alert, result: CheckResult):
        """Trigger automatic remediation."""
        try:

            # Get remediation suggestion
            remediation = self.knowledge.get_remediation_for_incident(
                symptoms=[result.error or "check failed"],
                service=result.check.target,
                title=alert.message,
            )

            if not remediation:
                logger.info(f"No remediation found for {alert.check_name}")
                return

            # Only auto-remediate if safe
            if not remediation.get("auto_executable", False):
                logger.info(f"Remediation for {alert.check_name} requires manual approval")
                return

            logger.info(f"Triggering auto-remediation for {alert.check_name}")
            self._stats["remediations_triggered"] += 1

            # Note: Actual execution would require context_manager
            # This is a placeholder for the integration point

        except Exception as e:
            logger.error(f"Remediation failed: {e}")

    # =========================================================================
    # Status & Reporting
    # =========================================================================

    def get_status(self) -> Dict[str, Any]:
        """Get sentinel status and statistics."""
        with self._lock:
            return {
                "status": self.status.value,
                "checks_configured": len(self._checks),
                "checks_enabled": sum(1 for c in self._checks.values() if c.enabled),
                "active_alerts": len(self._alerts),
                "stats": self._stats.copy(),
                "alerts": [
                    {
                        "id": a.id,
                        "target": a.target,
                        "severity": a.severity.value,
                        "message": a.message,
                        "failures": a.consecutive_failures,
                    }
                    for a in self._alerts.values()
                ],
            }

    def get_check_history(self, check_name: str, limit: int = 10) -> List[Dict]:
        """Get recent results for a check."""
        with self._lock:
            results = self._check_results.get(check_name, [])[-limit:]
            return [
                {
                    "success": r.success,
                    "response_time_ms": r.response_time_ms,
                    "timestamp": r.timestamp,
                    "error": r.error,
                }
                for r in results
            ]

    def get_alerts(self, include_acknowledged: bool = False) -> List[Alert]:
        """Get active alerts."""
        with self._lock:
            alerts = list(self._alerts.values())
            if not include_acknowledged:
                alerts = [a for a in alerts if not a.acknowledged]
            return alerts

    def acknowledge_alert(self, check_name: str) -> bool:
        """Acknowledge an alert."""
        with self._lock:
            if check_name in self._alerts:
                self._alerts[check_name].acknowledged = True
                return True
            return False


# Singleton instance
_sentinel_instance: Optional[SentinelAgent] = None


def get_sentinel_agent(
    executor=None,
    auto_remediate: bool = False,
) -> SentinelAgent:
    """Get or create the sentinel agent instance."""
    global _sentinel_instance

    if _sentinel_instance is None:
        _sentinel_instance = SentinelAgent(
            executor=executor,
            auto_remediate=auto_remediate,
        )

    return _sentinel_instance
